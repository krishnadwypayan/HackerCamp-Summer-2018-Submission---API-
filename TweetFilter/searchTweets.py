from main import *
from tweepy import Stream
from tweepy import OAuthHandler
from tweepy.streaming import StreamListener
from threading import Thread
from pymongo import Connection
from pymongo.errors import ConnectionFailure
from datetime import datetime
from email.utils import parsedate_tz, mktime_tz
import pytz
from pytz import reference

# this list holds the tweets generated by the thread running in the background responsible to live stream the tweets.
output = []

class listener(StreamListener):
	# The thread runs for the time_limit set.
	def __init__(self, time_limit=60):
		self.start_time = time.time()
		self.limit = time_limit
		super(listener, self).__init__()

	# On receiving data, this function inserts the tweet details into the Database.
	def on_data(self, data):
		if (time.time() - self.start_time) < self.limit:
			tweet = json.loads(data)
			tweet_id = tweet['id_str']
			
			tweet_time = tweet['created_at']
			timestamp = mktime_tz(parsedate_tz(tweet_time))
			dt = datetime.fromtimestamp(timestamp, pytz.timezone('Asia/Kolkata'))
			tweet_time = dt.strftime('%a %b %d %Y-%m-%d %H:%M:%S')
			
			tweet_text = tweet['text'].encode("utf-8")
			tweet_screen_name = tweet['user']['screen_name'].encode("utf-8")
			tweet_in_reply_to_screen_name = tweet['in_reply_to_screen_name']
			tweet_lang = tweet['user']['lang']
			tweet_user_followers_count = tweet['user']['followers_count']
			tweet_user_friends_count = tweet['user']['friends_count']
			tweet_user_listed_count = tweet['user']['listed_count']
			tweet_user_favourites_count = tweet['user']['favourites_count']
			tweet_retweet_count = tweet['retweet_count']
			tweet_entities_hashtags = tweet['entities']['hashtags']
			tweet_entities_urls = tweet['entities']['urls']
			tweet_entities_user_mentions = tweet['entities']['user_mentions']
			tweet_entities_user_mentions_name = ""
			tweet_entities_user_mentions_screen_name = ""
			for vals in tweet_entities_user_mentions:
				tweet_entities_user_mentions_name = vals['name'].encode("utf-8")
				tweet_entities_user_mentions_screen_name = vals['screen_name'].encode("utf-8")
			tweet_user_location = tweet['user']['location']
			tweet_place_country = ""
			tweet_place_name = ""
			if tweet['place'] is not None:
				tweet_place_country = tweet['place']['country']
				tweet_place_name = tweet['place']['name']

			inside_output = {'tweet_id' : tweet_id, 'tweet_time' : tweet_time, 'tweet_screen_name' : tweet_screen_name,
					'tweet_text' : tweet_text, 'tweet_lang' : tweet_lang, 'tweet_user_followers_count' : tweet_user_followers_count,
					'tweet_user_friends_count' : tweet_user_friends_count, 'tweet_user_listed_count' : tweet_user_listed_count,
					'tweet_user_favourites_count' : tweet_user_favourites_count, 'tweet_retweet_count' : tweet_retweet_count,
					'tweet_in_reply_to_screen_name' : tweet_in_reply_to_screen_name, 'tweet_place_country' : tweet_place_country,
					'tweet_place_name' : tweet_place_name, 'tweet_user_location' : tweet_user_location,	'tweet_entities_hashtags' : tweet_entities_hashtags, 
					'tweet_entities_urls' : tweet_entities_urls, 'tweet_entities_user_mentions_name' : tweet_entities_user_mentions_name, 
					'tweet_entities_user_mentions_screen_name' : tweet_entities_user_mentions_screen_name}
			
			try:
				c = Connection(host="localhost", port=27017)
			except ConnectionFailure, e:
				sys.stderr.write("Could not connect to MongoDB: %s" % e)
				sys.exit(1)
			dbh = c["tweets_db"]
			assert dbh.connection == c
			dbh.tweets.insert(inside_output, safe=True)
			
			csv = open(os.path.join(os.getcwd()+'/CSV/stream_tweets.csv'), 'a')
			row = str(tweet_time) + "," + str('"' + tweet_text + '"') + "," + str('"' + tweet_screen_name + '"') + "\n"
			csv.write(row)
			return True
		else:
			return False

	def on_error(self, status_code):
		if status_code == 420:
			return False


#Function that prints the exception message.
def getExceptionMessage(msg):
	words = msg.split(' ')

	errorMsg = ""
	for index, word in enumerate(words):
		if index not in [0,1,2]:
			errorMsg = errorMsg + ' ' + word
	errorMsg = errorMsg.rstrip("\'}]")
	errorMsg = errorMsg.lstrip(" \'")
	return errorMsg

# Streams the tweets of the user from his/her timeline.
def getTweetsOfScreenName(api, screen_name, page):
	alltweets = []
	try:
		new_tweets = api.user_timeline(screen_name = screen_name,count=200)
		alltweets.extend(new_tweets)
		outtweets = [[tweet.id_str, tweet.user.screen_name, tweet.created_at, tweet.text.encode("utf-8")] for tweet in alltweets]
		with open(os.path.join(os.getcwd()+'/CSV/%s_timeline_tweets_%s.csv' %(screen_name ,str(page))), 'wb') as f:
			writer = csv.writer(f)
			writer.writerow(["tweet_id", "screen_name", "created_at", "text"])
			writer.writerows(outtweets)
		pass
	except tweepy.TweepError as e:
		print e.api_code
		print getExceptionMessage(e.reason)

	return alltweets[(page-1)*10:(page-1)*10 + 10]

# Get live twitter streaming
def streamTwitterFeedThread(auth, search_string):
	twitterStream = Stream(auth, listener(time_limit=60))
	twitterStream.filter(track=[search_string])

# Get all the tweets from the database of the search_string and their metadata. 
# Background thread runs at all times to keep a live stream of the tweets.
def getAllTweets(auth, search_string, page):
	try:
		c = Connection(host="localhost", port=27017)
	except ConnectionFailure, e:
		sys.stderr.write("Could not connect to MongoDB: %s" % e)
		sys.exit(1)
	dbh = c["tweets_db"]
	assert dbh.connection == c
	dbh.tweets.remove({})

	try:
		os.remove(os.path.join(os.getcwd()+'/CSV/stream_tweets.csv'))
	except OSError:
		pass
	with open(os.path.join(os.getcwd()+'/CSV/stream_tweets.csv'), 'a') as f:
		writer = csv.writer(f)
		writer.writerow(["created_at", "text", "screen_name"])
	thread = Thread(target=streamTwitterFeedThread, args=(auth, search_string,))
	thread.daemon = True
	thread.start()
	return output[(page-1)*10:(page-1)*10 + 10]